use serde::{Deserialize};

#[derive(Debug, Deserialize)]
struct I18nHeader {
    platform: Vec<Pair>,
}

#[derive(Debug, Deserialize)]
struct Pair {
    key: String,
    value: String,
}

#[derive(Debug, Deserialize)]
struct I18nKeywords {
    keywords: Vec<String>,
}

pub mod i18n_compiler {
    use std::collections::HashMap;
    use std::fs::{create_dir_all, File};
    use std::io::Write;
    use std::path::Path;
    use csv::Reader;
    use serde_json::{from_str};
    use crate::i18n_compiler::{I18nHeader, I18nKeywords, Pair};

    pub fn compile(platform: &str, input: &str, output: &str) {
        let result = File::open(input);
        match result {
            Ok(file) => {
                let mut rdr = Reader::from_reader(file);
                let mut headers_:Vec<Pair> = Vec::new();
                let mut keywords:Vec<String> = Vec::new();
                if let Ok(headers) = rdr.headers() {
                    let result: Result<I18nKeywords, serde_json::Error> = from_str(headers.get(0).unwrap());
                    match result {
                        Ok(data) => {
                            keywords = data.keywords
                        }
                        Err(e) => {
                            eprintln!("Error parse header keywords json {}: {}", headers.get(0).unwrap(), e);
                        }
                    }
                    for index in 1..headers.len() {
                        let js = headers.get(index).unwrap().to_string();
                        let result: Result<I18nHeader, serde_json::Error> = from_str(js.as_str());
                        match result {
                            Ok(data) => {
                                let mut found = false;
                                for pair in data.platform {
                                    if pair.key == platform {
                                        found = true;
                                        headers_.push(pair)
                                    }
                                }
                                if !found {
                                    eprintln!("Error platform '{}' not found", platform);
                                }
                            }
                            Err(e) => {
                                eprintln!("Error parse json {}: {}", js, e);
                            }
                        }
                    }
                }
                let mut columns:HashMap<usize, Vec<Pair>> = HashMap::new();
                for result in rdr.records() {
                    let record = result.unwrap();

                    for index in 1..record.len() {
                        let pair = Pair {
                            key:record.get(0).unwrap().to_string(),
                            value: record.get(index).unwrap().to_string(),
                        };

                        let key = index.clone() - 1;
                        let column = columns.entry(key).or_insert(Vec::new());
                        column.push(pair);
                    }
                }

                for index in 0..headers_.len() {
                    let header = headers_.get(index.clone()).unwrap();
                    let pair = columns.get(&index).unwrap();
                    for x in pair {
                        if x.key.len()==0 {
                            panic!("{}", "key's length must > 0, can not be empty.")
                        }
                        if keywords.contains(&x.key) {
                            panic!("{}", "please do not use Keywords: ".to_string() + &*x.key.to_string() + " as key.")
                        }
                    }
                    let file = format!("{}/{}", output,header.value.clone());
                    let path = Path::new(file.as_str());

                    if let Some(parent) = path.parent() {
                        create_dir_all(parent).unwrap()
                    }
                    let output:File = File::create(file).unwrap();

                    match platform.to_lowercase().as_str() {
                        "ios" => compile_ios(output,pair),
                        "android" => compile_android(output,pair),
                        "web" => compile_web(output,pair),
                        _ => eprintln!("Error platform {} not support", platform),
                    }
                }
            }
            Err(error) => {
                eprintln!("Error opening {}: {}", input, error);
            }
        }
        return ;
    }
    fn compile_ios(mut output: File, pair: &Vec<Pair>) {
        output.write(b"// <!--This file is auto generated by i18n_compiler. Please Do not modify-->\n").unwrap();
        for x in pair {
            let mut value = x.value.clone();
            if value.contains("${}") {
                value = value.replace("${}", "%@");
            }
            if value.contains("\"") {
                value = value.replace("\"", "\\\"")
            }
            if value.len()==0 {
                value = format!("TODO: {}", x.key)
            }
            output.write(format!("\"{}\"=\"{}\"\n", x.key, value).as_bytes()).unwrap();
        }
    }
    fn compile_android(mut output: File, pair: &Vec<Pair>) {
        output.write(b"<!--This file is auto generated by i18n_compiler. Please Do not modify-->\n").unwrap();
        output.write(b"<resources>\n").unwrap();
        for x in pair {
            let mut value = x.value.clone();
            if value.contains("${}") {
                value = value.replace("${}", "%1s");
            }
            if value.contains("\'") {
                value = value.replace("\'", "\\'")
            }
            if value.contains("@") {
                value = value.replace("@", "\\@")
            }
            if value.len()==0 {
                value = format!("TODO: {}", x.key)
            }
            output.write(format!("\t<string name=\"{}\">{}</string>\n", x.key, value).as_bytes()).unwrap();
        }
        output.write(b"</resources>").unwrap();
    }
    fn compile_web(mut output: File, pair: &Vec<Pair>) {
        output.write(b"{\n").unwrap();
        output.write(format!("\t\"{}\" : \"{}\",\n", "ThisFileIsAutoGeneratedByI18NCompilerPleaseDoNotModify",
                             "<!--This file is auto generated by i18n_compiler. Please Do not modify-->").as_bytes()).unwrap();
        for x in pair {
            let mut value = x.value.clone();
            if value.contains("\\\"") || value.contains("\\'") {
                panic!("{}", "资源文件不需要对'和\"进行转译,请去掉符号前面的\\")
            }
            if value.contains("${}") {
                let mut numbers = 0;
                while value.contains("${}") {
                    let offset = value.find("${}").unwrap_or(value.len());
                    value.replace_range(offset.clone()..offset + 3, &format!("{{value{}}}", numbers));
                    numbers += 1;
                }
            }
            if value.contains("\"") {
                value = value.replace("\"", "\\\"")
            }
            if value.len()==0 {
                value = format!("TODO: {}", x.key)
            }
            output.write(format!("\t\"{}\" : \"{}\",\n", x.key, value).as_bytes()).unwrap();
        }
        output.write(b"}").unwrap();
    }
}